#lang sicp

(define (make-deque)
  (begin
    (define (make-node value prev)
      (cons (cons value prev) '()))
    (define (get-prev e)
      (cdr (car e)))
    (define (get-value e)
      (car (car e)))
    (define (set-prev! e prev)
      (set-car! e (cons (get-value e) prev)))

    (let ((front-ptr '())
          (rear-ptr '()))
      
      (define (empty-deq?)
        (null? front-ptr))
      
      (define (insert-deq-rear! item)
        (if (empty-deq?)
            (let ((new-item (make-node item '())))
              (set! front-ptr new-item )
              (set! rear-ptr front-ptr)
              dispatch)
            (let ((new-item (make-node item rear-ptr)))
              (set-cdr! rear-ptr new-item)
              (set! rear-ptr new-item)
              dispatch)))

      (define (delete-deq-rear!)
        (if (empty-deq?)
            (error "DELETE REAR! вызвана с пустым деком")
            (let ((prev (get-prev rear-ptr))
                  (value (get-value rear-ptr)))
              (if (null? prev)
                  (begin
                    (set! front-ptr '())
                    (set! rear-ptr '())
                    value)
                  (begin
                    (set-cdr! prev '())
                    (set! rear-ptr prev)
                    value)))))

      (define (insert-deq-front! item)
        (if (empty-deq?)
            (let ((new-item (make-node item '())))
              (set! front-ptr new-item )
              (set! rear-ptr front-ptr)
              dispatch)
            (let ((new-item (make-node item '())))
              (set-cdr! new-item front-ptr)
              (set-prev! front-ptr new-item)
              (set! front-ptr new-item)
              dispatch)))

      (define (delete-deq-front!)
        (if (empty-deq?)
            (error "DELETE REAR! вызвана с пустым деком")
            (let ((next (cdr front-ptr))
                  (value (get-value front-ptr)))
              (if (null? next)
                  (begin
                    (set! front-ptr '())
                    (set! rear-ptr '())
                    value)
                  (begin
                    (set! front-ptr next)
                    (set-prev! front-ptr '())
                    value)))))

      (define (print-deq)
        (define (iter tail)
          (if (null? tail)
              (newline)
              (begin
                (display (get-value tail))
                (display "; ")
                (iter (cdr tail)))))
        (display "deque | ")
        (iter front-ptr))
      
      (define (dispatch m . args)
        (cond ((eq? m 'empty?) (empty-deq?))
              ((eq? m 'insert-rear!) (insert-deq-rear! (car args)))
              ((eq? m 'delete-rear!) (delete-deq-rear!))
              ((eq? m 'insert-front!) (insert-deq-front! (car args)))
              ((eq? m 'delete-front!) (delete-deq-front!))
              ((eq? m 'print) (print-deq))
              (else (error "DISPATCH неверное имя метода" m))))
      
      dispatch)))

(define d1 (make-deque))
(d1 'print)
(d1 'insert-rear! 'a)
(d1 'print)
(d1 'insert-rear! 'b)
(d1 'print)
(d1 'insert-rear! 'c)
(d1 'print)
(d1 'insert-rear! 'd)
(d1 'print)
(d1 'delete-rear!)
(d1 'print)
(d1 'delete-rear!)
(d1 'print)
(d1 'delete-rear!)
(d1 'print)
(d1 'delete-rear!)
(d1 'print)
(d1 'insert-front! 'a)
(d1 'print)
(d1 'insert-front! 'b)
(d1 'print)
(d1 'insert-front! 'c)
(d1 'print)
(d1 'insert-front! 'd)
(d1 'print)
(d1 'insert-rear! 'e)
(d1 'print)
(d1 'insert-rear! 'f)
(d1 'print)
(d1 'delete-front!)
(d1 'print)
(d1 'delete-front!)
(d1 'print)
(d1 'delete-rear!)
(d1 'print)
(d1 'delete-rear!)